<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Seyes——基于OpenCV实现人脸瞳孔侦测的安卓应用（1）]]></title>
    <url>%2F2019%2F06%2F02%2FSeyes%2F%E5%9F%BA%E4%BA%8EOpenCV%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E7%9E%B3%E5%AD%94%E4%BE%A6%E6%B5%8B%E7%9A%84%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[此应用目的为检测用户与设备的距离并实现提醒。核心技术使用OpenCV。核心算法为检测瞳孔的距离以推算实现用户与设备的距离。 本章主要讨论了瞳孔侦测的核心算法以及在OpenCV for Android的实现方法。 导入 OpenCV for Android 到 AndroidStudio 利用已有的OpenCV级联分类器识别出人脸部分这里主要使用OpenCV的级联分类器CascadeClassifier类的实例，该实例具有方法detectMultiScale(...),通过该方法可以将输入的图像的特征部分保存到一个MatOfRect类当中。后续我们对瞳孔的处理都是针对这个MatOfRect实例。代码示例如下：12//@param, inputMat是你输入的Mat，matOfRect是检测后的输出，scaleFactor，minNeighbors, flags参数与具体的实现算法有关，而后面是检测的最小与最大size。faceCascadeClassifier.detectMultiScale(inputMat, matOfRect, scaleFactor, minNeighbors， flags，minSize()，maxSize()); 通过这个方法我们最终可以得到一个matOfRect，这是类MatOfRect实例。实际上MatOfRect相当于一个Rect数组，我们可以使用其提供的toArray()方法得到一系列Rect，每一个Rect矩阵对应了一个识别出来的特征图形在原图的位置。 在这里我们的cascadeClassifier使用了OpenCV提供的分类器lbpcascade_frontalface.xml，这是对人脸进行分类的一个xml文件。则我们得到的MatOfRect存储了检测出的所有face。以下代码则可以得到包含所有face的一个Rect数组。1Rect[] facesArray = matOfRect.toArray(); 根据人脸进行眼部的图片的范围扣取在上述结果基础上，我们在脸部进行一个眼部扣取，通过对人脸的比例划分出大致包含了眼睛的部分并保存到一个Rect当中，以提高后续检测眼睛的精确率。12345678910for(int i=0; i&lt;facesArray.length; i++)&#123; Rect tempFace = facesArray[i]; Rect eyearea_right = new Rect(tempFace.x + tempFace.width / 16, (int) (tempFace.y + (tempFace.height / 4.5)), (tempFace.width - 2 * tempFace.width / 16) / 2, (int) (tempFace.height / 3.0)); Rect eyearea_left = new Rect(tempFace.x + tempFace.width / 16 + (tempFace.width - 2 * tempFace.width / 16) / 2, (int) (tempFace.y + (tempFace.height / 4.5)), (tempFace.width - 2 * tempFace.width / 16) / 2, (int) (tempFace.height / 3.0)); //后续操作...&#125; 通过级联分类器识别人眼首先我们需要根据上一步大致划分的人眼区域，在原图中扣取出来一个Mat。这个Mat即是上一步扣取的图像，它将作为我们的人眼识别的原图。Mat类的submat函数可实现此需求：1Mat left_eyeMat = inputMat.submat(eyearea_left); 然后通过现有的人眼级联分类器识别出眼部,并保存到MatOfRect的实例eyeROI当中：1eyeCascadeClassifier.detectMultiScale(left_eyeMat, left_eyeROI, scaleFactor, minNeighbors， flags，minSize()，maxSize()); 对检测出的人眼部分进行瞳孔检测我们对瞳孔检测处理的算法是使用灰度图求最大灰度值。及默认人眼瞳孔相对于整个眼部的灰度值最大，通俗来讲就是瞳孔最黑，最黑的这个点就是我们的目标。 将人眼部分转换为灰度图。通过OpenCV的Imgproc类的cvtColor()函数完成。 123456789//把检测出的结果用矩阵表示Rect[] left_eyeROIArray = left_eyeROI.toArray();//检查bad dataif(left_eyeROIArray==null) return;//这里的矩阵是相对于上一步划分出的人眼范围图//同样需要根据人眼范围Mat来切割出人眼位置Mat srcMat = left_eyeMat.submat(left_eyeROIArray[0]);Mat dstMat;Imgproc.cvtColor(srcMat,dstMat,Imgproc.COLOR_BGRA2GRAY); 计算最大灰度值坐标，这里使用Core类的minMaxLoc(Mat grayMat)函数。 12Core.minmaxLocResult minMaxLocResult = Core.minMaxLoc(dstMat);Point leftPupil = minMaxLocResult.MaxLoc; Note： 这里需要理解参照物的区别。我们得到的leftPupil这个坐标是参照dstMat而言，等价于是参照我们检测出的眼部，也就是left_eyeROI对应的Mat。而后面我们计算瞳孔距离需要一步步把参照物还原到最开始的输入图像inputMat。 计算瞳距假定现在已经求出一张脸的两个瞳孔坐标pupil[0],pupil[1]。则我们需要以下步骤将该坐标变为相对于最开始输入的图像的坐标。 123456789//将相对于检测眼部参照物的坐标变换到划分眼部参照物坐标。pupils[0].x += left_eyeROIArray[0].x;pupils[0].y += left_eyeROIArray[0].y;//将相对于划分眼部参照物坐标变换到脸部参照物坐标。pupils[0].x += eyearea_left.x;pupils[0].y += eyearea_left.y;//将相对于眼部参照物坐标变换到原图坐标pupils[0].x += facesArray[i].x;pupils[0].y += facesArray[i].y; 则最终我们得到人眼瞳孔坐标，也就可以计算瞳孔距离。 Note: 这里的没有必要增加计算量严格按照勾股定理求距离，只需要平方和即可。 而后，我们将讨论如何进行安卓应用模块设计。]]></content>
      <categories>
        <category>OpenCV &amp; Android</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在AndroidStudio中配置OpenCV(需要Manager支持)]]></title>
    <url>%2F2019%2F06%2F01%2FSeyes%2F%E5%9C%A8AndroidStudio%E4%B8%AD%E9%85%8D%E7%BD%AEOpenCV%2F</url>
    <content type="text"><![CDATA[本文讲解了如何在AndroidStudio中导入OpenCV，这种方式需要使用OpenCV官方给出的OpenCV Manager的支持，可自行前往下载（OpenCV3.3.0之前包含了Manager apk）。 配置 前往 OpenCV 官网（OpenCV的github地址）下载OpenCV for Android的Sdk。选择相应的版本，之后选择Android。下载完毕后解压。则大致目录结构如下（下面目录结构为OpenCV-2.4.9结构）： 1234567891011121314151617181920OpenCV-2.4.9-android-sdk|_ apk| |_ OpenCV_2.4.9_binary_pack_armv7a.apk| |_ OpenCV_2.4.9_Manager_2.18_XXX.apk||_ doc|_ samples|_ sdk| |_ etc| |_ java| |_ native| |_ 3rdparty| |_ jni| |_ libs| |_ armeabi| |_ armeabi-v7a| |_ x86||_ LICENSE|_ README.android apk 目录存放OpenCV支持apk应用，需要预先安装到设备上作为支持。 samples 目录存放官方给出的示例程序。 sdk 目录包含OpenCV的API和Android的依赖项。 sdk/etc 包含Haar和LBP级联分类器。 sdk/java 包含必要的OpenCV Java API。 sdk/native 包含OpenCV C++头文件（为JNI提供的代码）和native Android依赖（.so和.a）和libs文件下对各种CPU架构提供的支持。 在AndroidStudio中新建一个空的项目，点击 File-&gt;new-&gt;Import Module。选择刚下载的OpenCV sdk的[sdk路径]/sdk/java目录，并将Module命名为OpenCV[版本号]Library。，完成后，IDE项目目录会出现新的Module目录，选择其对应的build.gradle。 打开项目的app目录对应的build.gradle，将OpenCV的Module下的build.gradle中的compileSdkVersion，minSdkVersion, targetSdkVersion修改成你的app对应的build.gradle中的version。 Note: 注意你的OpenCV Module对应的buile.gradle中的apply plug，需要将其值改为&#39;com.android.library&#39;,同时删除android-&gt;defaultConfig下的applicationId，否则将会导致同步失败。 本博文对应的.gradle文件如下,请根据你自己的app的build.gradle进行修改。 123456789101112131415161718192021apply plugin: &apos;com.android.library&apos; //此处需要修改android &#123; //此处compileSdkVersion修改为你的app对应的build.gradle的版本号 compileSdkVersion 28 buildToolsVersion &quot;28.0.2&quot; defaultConfig &#123; //此处minSdkVersion,targetSdkVersion修改为你的app对应的build.gradle的版本号 minSdkVersion 23 targetSdkVersion 28 //如果有applicationId标签，需要删除 &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.txt&apos; &#125; &#125;&#125; 点击File-&gt;Project Structure,点击app-&gt;Dependencies，可以在这个界面看到app的依赖列表。点击加号-&gt;Module dependency,然后选择第2步引入的OpenCV Module，完毕后不出意外项目会构建并且同步成功。 测试以及简单demo的学习经过以上的步骤你的OpenCV已经成功配置到AndroidStudio，如果你是刚入门OpenCV for Android,不妨详细阅读本小节。本小节将展示如何在Android调用摄像头，并实现一个简单的图像处理。 创建一个新的Activity，并设置为Launcher Activity（勾选Launcher Activity选项）。 编辑新创建的activity文件。在Activity文件中添加以下代码使得能够初始化OpenCV依赖库。这里会出现报错，我们先将错误放置一旁。 1234567891011121314151617181920212223242526private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) &#123; //这里 @Override public void onManagerConnected(int status) &#123; switch (status) &#123; case LoaderCallbackInterface.SUCCESS: &#123; Log.i(TAG, "OpenCV loaded successfully"); mOpenCvCameraView.enableView(); &#125; break; default: &#123; super.onManagerConnected(status); &#125; break; &#125; &#125;&#125;;@Overridepublic void onResume()&#123; super.onResume(); //这里加载OpenCV支持程序，使用OpenCV Mannager。 //请自行更改你在模拟器上或安卓设备上安装的OpenCV Manager版本。 OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_3_0, this, mLoaderCallback);&#125; 这里的OpenCVLoader.OPENCV_VERSION_3_3_0版本错误将会导致初始化OpenCV库失败，请正确填写所安装的版本。 编辑Activity文件。首先让你的activity class实现CVCameraViewListener2接口。然后根据以下代码进行添加。 12345678910111213141516171819202122232425262728293031323334353637383940414243private static final String TAG = "In TestOpenCVCamera";//这里的CameraBridgeViewBase类主要用来控制什么时候Camera可用、//处理相机产生的frame，调用已有的监听器对frame调整和输出。private CameraBridgeViewBase mOpenCvCameraView;@Overridepublic void onCreate(Bundle savedInstanceState) &#123; Log.i(TAG, "called onCreate"); super.onCreate(savedInstanceState); getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); setContentView(R.layout.content_test_open_cvcamera);//此处自行修改对应的布局文件 mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.HelloOpenCvView);//绑定控件 mOpenCvCameraView.setVisibility(SurfaceView.VISIBLE);//设置此时SurfaceView可见 mOpenCvCameraView.setCvCameraViewListener(this);//设置监听器&#125;@Overridepublic void onPause()&#123; super.onPause(); if (mOpenCvCameraView != null) mOpenCvCameraView.disableView();&#125;public void onDestroy() &#123; super.onDestroy(); if (mOpenCvCameraView != null) mOpenCvCameraView.disableView();&#125;public void onCameraViewStarted(int width, int height) &#123; //接口要求必须的实例化的方法，此处设置为空方法&#125;public void onCameraViewStopped() &#123; //接口要求必须的实例化的方法，此处设置为空方法&#125;public Mat onCameraFrame(CameraBridgeViewBase.CvCameraViewFrame inputFrame) &#123; //这个方法为对获取的图像（此处为frame）的处理，输入frame，输出frame //这个方法为接口要求的必须的方法 return inputFrame.gray();//转换为灰度图像&#125; 解决好import的包问题，处理好报错。示例的activity文件如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.example.tristan.seyes_20190601;import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.SurfaceView;import android.view.WindowManager;import org.opencv.android.BaseLoaderCallback;import org.opencv.android.CameraBridgeViewBase;import org.opencv.android.LoaderCallbackInterface;import org.opencv.android.OpenCVLoader;import org.opencv.core.Mat;public class TestOpenCVCamera extends Activity implements CameraBridgeViewBase.CvCameraViewListener2 &#123; //这里实现了CVCameraViewListener2接口。 private static final String TAG = "In TestOpenCVCamera"; //这里的CameraBridgeViewBase类主要用来控制什么时候Camera可用、 //处理相机产生的frame，调用已有的监听器对frame调整和输出。 private CameraBridgeViewBase mOpenCvCameraView; @Override public void onCreate(Bundle savedInstanceState) &#123; Log.i(TAG, "called onCreate"); super.onCreate(savedInstanceState); getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); setContentView(R.layout.content_test_open_cvcamera);//此处自行修改对应的布局文件 mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.HelloOpenCvView);//绑定控件 mOpenCvCameraView.setVisibility(SurfaceView.VISIBLE);//设置此时SurfaceView可见 mOpenCvCameraView.setCvCameraViewListener(this);//设置监听器 &#125; @Override public void onPause() &#123; super.onPause(); if (mOpenCvCameraView != null) mOpenCvCameraView.disableView(); &#125; public void onDestroy() &#123; super.onDestroy(); if (mOpenCvCameraView != null) mOpenCvCameraView.disableView(); &#125; public void onCameraViewStarted(int width, int height) &#123; //接口要求必须的实例化的方法，此处设置为空方法 &#125; public void onCameraViewStopped() &#123; //接口要求必须的实例化的方法，此处设置为空方法 &#125; public Mat onCameraFrame(CameraBridgeViewBase.CvCameraViewFrame inputFrame) &#123; //这个方法为对获取的图像（此处为frame）的处理，输入frame，输出frame //这个方法为接口要求的必须的方法 return inputFrame.gray();//转换为灰度图像 &#125; private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) &#123; //这里 @Override public void onManagerConnected(int status) &#123; switch (status) &#123; case LoaderCallbackInterface.SUCCESS: &#123; Log.i(TAG, "OpenCV loaded successfully"); mOpenCvCameraView.enableView(); &#125; break; default: &#123; super.onManagerConnected(status); &#125; break; &#125; &#125; &#125;; @Override public void onResume() &#123; super.onResume(); //这里加载OpenCV支持程序，使用OpenCV Mannager。 //请自行更改你在模拟器上或安卓设备上安装的OpenCV Manager版本。 OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_3_0, this, mLoaderCallback); &#125;&#125; 编辑对应的Layout布局文件。 123456789101112131415&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"xmlns:opencv="http://schemas.android.com/apk/res-auto"android:layout_width="match_parent"android:layout_height="match_parent" &gt;&lt;org.opencv.android.JavaCameraView android:layout_width="fill_parent" android:layout_height="fill_parent" android:visibility="gone" android:id="@+id/HelloOpenCvView" opencv:show_fps="true" opencv:camera_id="any" /&gt;&lt;/LinearLayout&gt; 在AndroidManifest.xml文件第二级标签添加App权限，用以实现调用Camera。 12345&lt;uses-permission android:name="android.permission.CAMERA"/&gt;&lt;uses-feature android:name="android.hardware.camera" android:required="false"/&gt;&lt;uses-feature android:name="android.hardware.camera.autofocus" android:required="false"/&gt;&lt;uses-feature android:name="android.hardware.camera.front" android:required="false"/&gt;&lt;uses-feature android:name="android.hardware.camera.front.autofocus" android:required="false"/&gt; 经过以上步骤，连接真机调试安装，赋予应用摄像机权限，可以看到该应用如何从摄像头获取图像并转换为灰度图。]]></content>
      <tags>
        <tag>OpenCV</tag>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
