<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于OpenCV实现人脸瞳孔侦测的安卓应用————Seyes（1）]]></title>
    <url>%2F2019%2F06%2F01%2F%E5%9F%BA%E4%BA%8EOpenCV%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E7%9E%B3%E5%AD%94%E4%BE%A6%E6%B5%8B%E7%9A%84%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%2F%E5%9F%BA%E4%BA%8EOpenCV%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E7%9E%B3%E5%AD%94%E4%BE%A6%E6%B5%8B%E7%9A%84%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[绪论此应用目的为检测用户与设备的距离并实现提醒。核心技术使用OpenCV。核心算法为检测瞳孔的距离以推算实现用户与设备的距离。 准备导入 OpenCV for Android 到 AndroidStudio 前往 OpenCV 官网（OpenCV的github地址）下载OpenCV for Android的Sdk。选择相应的版本，之后选择Android。下载完毕后解压。则大致目录结构如下（下面目录结构为OpenCV-2.4.9结构）： 1234567891011121314151617181920OpenCV-2.4.9-android-sdk|_ apk| |_ OpenCV_2.4.9_binary_pack_armv7a.apk| |_ OpenCV_2.4.9_Manager_2.18_XXX.apk||_ doc|_ samples|_ sdk| |_ etc| |_ java| |_ native| |_ 3rdparty| |_ jni| |_ libs| |_ armeabi| |_ armeabi-v7a| |_ x86||_ LICENSE|_ README.android apk 目录存放OpenCV支持apk应用，需要预先安装到设备上作为支持。 samples 目录存放官方给出的示例程序。 sdk 目录包含OpenCV的API和Android的依赖项。 sdk/etc 包含Haar和LBP级联分类器。 sdk/java 包含必要的OpenCV Java API。 sdk/native 包含OpenCV C++头文件（为JNI提供的代码）和native Android依赖（.so和.a）和libs文件下对各种CPU架构提供的支持。 在AndroidStudio中新建一个空的项目，点击 File-&gt;new-&gt;Import Module。选择刚下载的OpenCV sdk的[sdk路径]/sdk/java目录，并将Module命名为OpenCV[版本号]Library。，完成后，IDE项目目录会出现新的Module目录，选择其对应的build.gradle。 打开项目的app目录对应的build.gradle，将OpenCV的Module下的build.gradle中的compileSdkVersion，minSdkVersion, targetSdkVersion修改成你的app对应的build.gradle中的version。 Note: 注意你的OpenCV Module对应的buile.gradle中的apply plug，需要将其值改为&#39;com.android.library&#39;,同时删除android-&gt;defaultConfig下的applicationId，否则将会导致同步失败。 本博文对应的.gradle文件如下,请根据你自己的app的build.gradle进行修改。 123456789101112131415161718192021apply plugin: &apos;com.android.library&apos; //此处需要修改android &#123; //此处compileSdkVersion修改为你的app对应的build.gradle的版本号 compileSdkVersion 28 buildToolsVersion &quot;28.0.2&quot; defaultConfig &#123; //此处minSdkVersion,targetSdkVersion修改为你的app对应的build.gradle的版本号 minSdkVersion 23 targetSdkVersion 28 //如果有applicationId标签，需要删除 &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.txt&apos; &#125; &#125;&#125; 点击File-&gt;Project Structure,点击app-&gt;Dependencies，可以在这个界面看到app的依赖列表。点击加号-&gt;Module dependency,然后选择第2步引入的OpenCV Module，完毕后不出意外项目会构建并且同步成功。 测试经过以上的步骤你的OpenCV已经成功配置到AndroidStudio，如果你是刚入门OpenCV for Android,不妨详细阅读本小节。本小节将展示如何在Android调用摄像头，并实现一个简单的图像处理。 创建一个新的Activity，并设置为Launcher Activity（勾选Launcher Activity选项）。 编辑新创建的activity文件。在Activity文件中添加以下代码使得能够初始化OpenCV依赖库。这里会出现报错，我们先将错误放置一旁。12345678910111213141516171819202122232425private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) &#123; //这里是一个基本的回调方法用来 @Override public void onManagerConnected(int status) &#123; switch (status) &#123; case LoaderCallbackInterface.SUCCESS: &#123; Log.i(TAG, "OpenCV loaded successfully"); mOpenCvCameraView.enableView(); &#125; break; default: &#123; super.onManagerConnected(status); &#125; break; &#125; &#125;&#125;; @Override public void onResume() &#123; super.onResume(); //这里加载OpenCV库（使用辅助的OpenCVManager），请自行修改你模拟器或者安卓设备上所安装的Manager版本。 OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_2_4_6, this, mLoaderCallback); &#125; 编辑Activity文件。首先让你的activity class实现CVCameraViewListener2接口。然后根据以下代码进行添加。 123456789101112131415161718192021222324252627282930313233343536 private CameraBridgeViewBase mOpenCvCameraView;@Overridepublic void onCreate(Bundle savedInstanceState) &#123; Log.i(TAG, "called onCreate"); super.onCreate(savedInstanceState); getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); setContentView(R.layout.HelloOpenCvLayout); mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.HelloOpenCvView); mOpenCvCameraView.setVisibility(SurfaceView.VISIBLE); mOpenCvCameraView.setCvCameraViewListener(this);&#125;@Overridepublic void onPause()&#123; super.onPause(); if (mOpenCvCameraView != null) mOpenCvCameraView.disableView();&#125;public void onDestroy() &#123; super.onDestroy(); if (mOpenCvCameraView != null) mOpenCvCameraView.disableView();&#125;public void onCameraViewStarted(int width, int height)&#123;&#125;public void onCameraViewStopped() &#123;&#125;public Mat onCameraFrame(CvCameraViewFrame inputFrame) &#123; return inputFrame.gray();&#125; 编辑对应的Layout布局文件。 123456789101112131415&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"xmlns:opencv="http://schemas.android.com/apk/res-auto"android:layout_width="match_parent"android:layout_height="match_parent" &gt;&lt;org.opencv.android.JavaCameraView android:layout_width="fill_parent" android:layout_height="fill_parent" android:visibility="gone" android:id="@+id/HelloOpenCvView" opencv:show_fps="true" opencv:camera_id="any" /&gt;&lt;/LinearLayout&gt; 在AndroidManifest.xml文件第二级标签添加App权限，用以实现调用Camera。 123456&lt;uses-permission android:name="android.permission.CAMERA"/&gt;&lt;uses-feature android:name="android.hardware.camera" android:required="false"/&gt;&lt;uses-feature android:name="android.hardware.camera.autofocus" android:required="false"/&gt;&lt;uses-feature android:name="android.hardware.camera.front" android:required="false"/&gt;&lt;uses-feature android:name="android.hardware.camera.front.autofocus" android:required="false"/&gt;]]></content>
      <tags>
        <tag>OpenCV</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在AndroidStudio中配置OpenCV(需要Manager支持)]]></title>
    <url>%2F2019%2F06%2F01%2F%E5%9F%BA%E4%BA%8EOpenCV%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E7%9E%B3%E5%AD%94%E4%BE%A6%E6%B5%8B%E7%9A%84%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%2F%E5%9C%A8AndroidStudio%E4%B8%AD%E9%85%8D%E7%BD%AEOpenCV(%E9%9C%80%E8%A6%81Manager%E6%94%AF%E6%8C%81)%2F</url>
    <content type="text"><![CDATA[本文讲解了如何在AndroidStudio中导入OpenCV，这种方式需要使用OpenCV官方给出的OpenCV Manager的支持，可自行前往下载（OpenCV3.3.0之前包含了Manager apk）。 前往 OpenCV 官网（OpenCV的github地址）下载OpenCV for Android的Sdk。选择相应的版本，之后选择Android。下载完毕后解压。则大致目录结构如下（下面目录结构为OpenCV-2.4.9结构）： 1234567891011121314151617181920OpenCV-2.4.9-android-sdk|_ apk| |_ OpenCV_2.4.9_binary_pack_armv7a.apk| |_ OpenCV_2.4.9_Manager_2.18_XXX.apk||_ doc|_ samples|_ sdk| |_ etc| |_ java| |_ native| |_ 3rdparty| |_ jni| |_ libs| |_ armeabi| |_ armeabi-v7a| |_ x86||_ LICENSE|_ README.android apk 目录存放OpenCV支持apk应用，需要预先安装到设备上作为支持。 samples 目录存放官方给出的示例程序。 sdk 目录包含OpenCV的API和Android的依赖项。 sdk/etc 包含Haar和LBP级联分类器。 sdk/java 包含必要的OpenCV Java API。 sdk/native 包含OpenCV C++头文件（为JNI提供的代码）和native Android依赖（.so和.a）和libs文件下对各种CPU架构提供的支持。 在AndroidStudio中新建一个空的项目，点击 File-&gt;new-&gt;Import Module。选择刚下载的OpenCV sdk的[sdk路径]/sdk/java目录，并将Module命名为OpenCV[版本号]Library。，完成后，IDE项目目录会出现新的Module目录，选择其对应的build.gradle。 打开项目的app目录对应的build.gradle，将OpenCV的Module下的build.gradle中的compileSdkVersion，minSdkVersion, targetSdkVersion修改成你的app对应的build.gradle中的version。 Note: 注意你的OpenCV Module对应的buile.gradle中的apply plug，需要将其值改为&#39;com.android.library&#39;,同时删除android-&gt;defaultConfig下的applicationId，否则将会导致同步失败。 本博文对应的.gradle文件如下,请根据你自己的app的build.gradle进行修改。 123456789101112131415161718192021apply plugin: &apos;com.android.library&apos; //此处需要修改android &#123; //此处compileSdkVersion修改为你的app对应的build.gradle的版本号 compileSdkVersion 28 buildToolsVersion &quot;28.0.2&quot; defaultConfig &#123; //此处minSdkVersion,targetSdkVersion修改为你的app对应的build.gradle的版本号 minSdkVersion 23 targetSdkVersion 28 //如果有applicationId标签，需要删除 &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.txt&apos; &#125; &#125;&#125; 点击File-&gt;Project Structure,点击app-&gt;Dependencies，可以在这个界面看到app的依赖列表。点击加号-&gt;Module dependency,然后选择第2步引入的OpenCV Module，完毕后不出意外项目会构建并且同步成功。 测试经过以上的步骤你的OpenCV已经成功配置到AndroidStudio，如果你是刚入门OpenCV for Android,不妨详细阅读本小节。本小节将展示如何在Android调用摄像头，并实现一个简单的图像处理。 创建一个新的Activity，并设置为Launcher Activity（勾选Launcher Activity选项）。 编辑新创建的activity文件。在Activity文件中添加以下代码使得能够初始化OpenCV依赖库。这里会出现报错，我们先将错误放置一旁。 1234567891011121314151617181920212223242526private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) &#123; //这里 @Override public void onManagerConnected(int status) &#123; switch (status) &#123; case LoaderCallbackInterface.SUCCESS: &#123; Log.i(TAG, "OpenCV loaded successfully"); mOpenCvCameraView.enableView(); &#125; break; default: &#123; super.onManagerConnected(status); &#125; break; &#125; &#125;&#125;;@Overridepublic void onResume()&#123; super.onResume(); //这里加载OpenCV支持程序，使用OpenCV Mannager。 //请自行更改你在模拟器上或安卓设备上安装的OpenCV Manager版本。 OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_3_0, this, mLoaderCallback);&#125; 这里的OpenCVLoader.OPENCV_VERSION_3_3_0版本错误将会导致初始化OpenCV库失败，请正确填写所安装的版本。 编辑Activity文件。首先让你的activity class实现CVCameraViewListener2接口。然后根据以下代码进行添加。 12345678910111213141516171819202122232425262728293031323334353637383940414243private static final String TAG = "In TestOpenCVCamera";//这里的CameraBridgeViewBase类主要用来控制什么时候Camera可用、//处理相机产生的frame，调用已有的监听器对frame调整和输出。private CameraBridgeViewBase mOpenCvCameraView;@Overridepublic void onCreate(Bundle savedInstanceState) &#123; Log.i(TAG, "called onCreate"); super.onCreate(savedInstanceState); getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); setContentView(R.layout.content_test_open_cvcamera);//此处自行修改对应的布局文件 mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.HelloOpenCvView);//绑定控件 mOpenCvCameraView.setVisibility(SurfaceView.VISIBLE);//设置此时SurfaceView可见 mOpenCvCameraView.setCvCameraViewListener(this);//设置监听器&#125;@Overridepublic void onPause()&#123; super.onPause(); if (mOpenCvCameraView != null) mOpenCvCameraView.disableView();&#125;public void onDestroy() &#123; super.onDestroy(); if (mOpenCvCameraView != null) mOpenCvCameraView.disableView();&#125;public void onCameraViewStarted(int width, int height) &#123; //接口要求必须的实例化的方法，此处设置为空方法&#125;public void onCameraViewStopped() &#123; //接口要求必须的实例化的方法，此处设置为空方法&#125;public Mat onCameraFrame(CameraBridgeViewBase.CvCameraViewFrame inputFrame) &#123; //这个方法为对获取的图像（此处为frame）的处理，输入frame，输出frame //这个方法为接口要求的必须的方法 return inputFrame.gray();//转换为灰度图像&#125; 解决好import的包问题，处理好报错。示例的activity文件如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.example.tristan.seyes_20190601;import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.SurfaceView;import android.view.WindowManager;import org.opencv.android.BaseLoaderCallback;import org.opencv.android.CameraBridgeViewBase;import org.opencv.android.LoaderCallbackInterface;import org.opencv.android.OpenCVLoader;import org.opencv.core.Mat;public class TestOpenCVCamera extends Activity implements CameraBridgeViewBase.CvCameraViewListener2 &#123; //这里实现了CVCameraViewListener2接口。 private static final String TAG = "In TestOpenCVCamera"; //这里的CameraBridgeViewBase类主要用来控制什么时候Camera可用、 //处理相机产生的frame，调用已有的监听器对frame调整和输出。 private CameraBridgeViewBase mOpenCvCameraView; @Override public void onCreate(Bundle savedInstanceState) &#123; Log.i(TAG, "called onCreate"); super.onCreate(savedInstanceState); getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); setContentView(R.layout.content_test_open_cvcamera);//此处自行修改对应的布局文件 mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.HelloOpenCvView);//绑定控件 mOpenCvCameraView.setVisibility(SurfaceView.VISIBLE);//设置此时SurfaceView可见 mOpenCvCameraView.setCvCameraViewListener(this);//设置监听器 &#125; @Override public void onPause() &#123; super.onPause(); if (mOpenCvCameraView != null) mOpenCvCameraView.disableView(); &#125; public void onDestroy() &#123; super.onDestroy(); if (mOpenCvCameraView != null) mOpenCvCameraView.disableView(); &#125; public void onCameraViewStarted(int width, int height) &#123; //接口要求必须的实例化的方法，此处设置为空方法 &#125; public void onCameraViewStopped() &#123; //接口要求必须的实例化的方法，此处设置为空方法 &#125; public Mat onCameraFrame(CameraBridgeViewBase.CvCameraViewFrame inputFrame) &#123; //这个方法为对获取的图像（此处为frame）的处理，输入frame，输出frame //这个方法为接口要求的必须的方法 return inputFrame.gray();//转换为灰度图像 &#125; private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) &#123; //这里 @Override public void onManagerConnected(int status) &#123; switch (status) &#123; case LoaderCallbackInterface.SUCCESS: &#123; Log.i(TAG, "OpenCV loaded successfully"); mOpenCvCameraView.enableView(); &#125; break; default: &#123; super.onManagerConnected(status); &#125; break; &#125; &#125; &#125;; @Override public void onResume() &#123; super.onResume(); //这里加载OpenCV支持程序，使用OpenCV Mannager。 //请自行更改你在模拟器上或安卓设备上安装的OpenCV Manager版本。 OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_3_0, this, mLoaderCallback); &#125;&#125; 编辑对应的Layout布局文件。 123456789101112131415&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"xmlns:tools="http://schemas.android.com/tools"xmlns:opencv="http://schemas.android.com/apk/res-auto"android:layout_width="match_parent"android:layout_height="match_parent" &gt;&lt;org.opencv.android.JavaCameraView android:layout_width="fill_parent" android:layout_height="fill_parent" android:visibility="gone" android:id="@+id/HelloOpenCvView" opencv:show_fps="true" opencv:camera_id="any" /&gt;&lt;/LinearLayout&gt; 在AndroidManifest.xml文件第二级标签添加App权限，用以实现调用Camera。 12345&lt;uses-permission android:name="android.permission.CAMERA"/&gt;&lt;uses-feature android:name="android.hardware.camera" android:required="false"/&gt;&lt;uses-feature android:name="android.hardware.camera.autofocus" android:required="false"/&gt;&lt;uses-feature android:name="android.hardware.camera.front" android:required="false"/&gt;&lt;uses-feature android:name="android.hardware.camera.front.autofocus" android:required="false"/&gt; 经过以上步骤，连接真机调试安装，赋予应用摄像机权限，可以看到该应用如何从摄像头获取图像并转换为灰度图。]]></content>
      <tags>
        <tag>OpenCV</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
